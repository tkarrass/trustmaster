package trustmaster

import (
	log "github.com/sirupsen/logrus"
	"net/http"
	"net/url"
	"strings"
	"io/ioutil"
	"encoding/json"
	"errors"
	"fmt"
	"time"
)

const api_base = "https://trust.reswue.net"

type trustmaster struct {
	ClientId string
	clientSecret string
	redirectUri string
}

// Create a new Trustmaster client object with the given credentials.
// Note: The redirect uri must match the uri specified at the client registration.
func NewClient(clientid, clientsecret, redirect string) (*trustmaster, error) {
	if clientid == "" {
		return nil, errors.New("missing client id")
	}
	if clientsecret == "" {
		return nil, errors.New("missing client secret")
	}
	if redirect == "" {
		return nil, errors.New("missing redirect uri")
	}
	ret := &trustmaster{
		ClientId: clientid,
		clientSecret: clientsecret,
		redirectUri: redirect,
	}
	version, err := ret.Version()
	if err != nil {
		return nil, err
	}
	if version != 2 {
		return nil, errors.New("incompatible backend version")
	}
	return ret, nil
}


// Retrieve the API version of the Trustmaster backend.
func (trm *trustmaster) Version() (uint, error) {
	c := http.Client{}
	url := fmt.Sprintf("%v/api/meta/version", api_base)
	req, err := http.NewRequest("GET", url, nil)
	if err != nil {
		return 0, err
	}
	ret, err := c.Do(req)
	if err != nil {
		return 0, err
	}
	if ret.StatusCode != 200 {
		return 0, errors.New(ret.Status)
	}
	rdata, _ := ioutil.ReadAll(ret.Body)
	log.Debug(string(rdata[:]))
	v := &Version{}
	err = json.Unmarshal(rdata, v)
	if err != nil {
		return 0, err
	}
	return v.Version, nil
}

// Get a generic access token using the credentials provided when
// creating the instance.
func (trm *trustmaster) GenericAccessToken() (*AccessToken, error) {
	c := http.Client{}
	data := url.Values{}
	data.Add("grant_type", "client_credentials")
	data.Add("client_id", trm.ClientId)
	data.Add("client_secret", trm.clientSecret)
	data.Add("scope", "")

	url := fmt.Sprintf("%v/oauth/token", api_base)
	req, err := http.NewRequest("POST", url, strings.NewReader(data.Encode()))
	if err != nil {
		return nil, err
	}

	req.Header.Set("Content-Type", "application/x-www-form-urlencoded")

	ret, err := c.Do(req)
	if err != nil {
		return nil, err
	}

	log.Info(ret.Status)
	if ret.StatusCode == 200 {
		rdata, _ := ioutil.ReadAll(ret.Body)
		log.Debug(string(rdata[:]))
		token := &AccessToken{}
		err = json.Unmarshal(rdata, token)
		if err != nil {
			return nil, err
		}
		// calculate expired time. assume network latency of 5 seconds.
		token.Expires = time.Now().Add(time.Duration(token.ExpiresIn-5) * time.Second)
		token.generic = true
		return token, nil
	}

	return nil, errors.New(ret.Status)
}

// Get an access token specific to a user, using the code provided by the
// backend. You need to forward your user to the URL generated by the
// AuthURL function. This will forward to the redirect uri you provided,
// where you should have a http handler taking the code you need.
func (trm *trustmaster) UserAccessToken(code string) (*AccessToken, error) {
	c := http.Client{}
	data := url.Values{}
	data.Add("grant_type", "authorization_code")
	data.Add("client_id", trm.ClientId)
	data.Add("client_secret", trm.clientSecret)
	data.Add("redirect_uri", trm.redirectUri)
	data.Add("code", code)
	url := fmt.Sprintf("%v/oauth/token", api_base)
	req, err := http.NewRequest("POST", url, strings.NewReader(data.Encode()))
	if err != nil {
		return nil, err
	}
	req.Header.Set("Content-Type", "application/x-www-form-urlencoded")
	ret, err := c.Do(req)
	if err != nil {
		return nil, err
	}

	log.Info(ret.Status)
	if ret.StatusCode == 200 {
		rdata, _ := ioutil.ReadAll(ret.Body)
		log.Debug(string(rdata[:]))
		token := &AccessToken{}
		err = json.Unmarshal(rdata, token)
		if err != nil {
			return nil, err
		}
		token.user = true
		// calculate expired time. assume network latency of 5 seconds.
		token.Expires = time.Now().Add(time.Duration(token.ExpiresIn-5) * time.Second)
		return token, nil
	}

	return nil, errors.New(ret.Status)
}

func (trm *trustmaster) RefreshToken(token *AccessToken) error {
	newtoken := &AccessToken{}
	if token.user {
		c := http.Client{}
		data := url.Values{}
		data.Add("grant_type", "refresh_token")
		data.Add("client_id", trm.ClientId)
		data.Add("client_secret", trm.clientSecret)
		data.Add("redirect_uri", trm.redirectUri)
		data.Add("refresh_token", token.RefreshToken)
		url := fmt.Sprintf("%v/oauth/token", api_base)
		req, err := http.NewRequest("POST", url, strings.NewReader(data.Encode()))
		if err != nil {
			return err
		}
		req.Header.Set("Content-Type", "application/x-www-form-urlencoded")
		ret, err := c.Do(req)
		if err != nil {
			return err
		}

		log.Info(ret.Status)
		if ret.StatusCode != 200 {
			return errors.New(ret.Status)
		}
		rdata, _ := ioutil.ReadAll(ret.Body)
		log.Debug(string(rdata[:]))
		err = json.Unmarshal(rdata, newtoken)
		if err != nil {
			return err
		}
		newtoken.user = true
		// calculate expired time. assume network latency of 5 seconds.
		newtoken.Expires = time.Now().Add(time.Duration(token.ExpiresIn-5) * time.Second)
	} else {
		// we cannot use refresh on generic tokens, since their
		// refresh_token is always empty
		var err error
		newtoken, err = trm.GenericAccessToken()
		if err != nil {
			return err
		}
	}
	token.Token = newtoken.Token
	token.ExpiresIn = newtoken.ExpiresIn
	token.RefreshToken = newtoken.RefreshToken
	token.Type = newtoken.Type
	token.user = newtoken.user
	token.generic = newtoken.generic
	token.Expires = newtoken.Expires
	return nil
}

// Create an URL using a given state tag and scope for user authentication.
func (trm *trustmaster) AuthURL(state string, scopes... Scope ) string {
	data := url.Values{}
	data.Add("client_id", trm.ClientId)
	data.Add("redirect_uri", trm.redirectUri)
	data.Add("response_type", "code")
	scopestring := make([]string, 0, len(scopes))
	for _, sc := range scopes {
		scopestring = append(scopestring, sc.String())
	}
	data.Add("scope", strings.Join(scopestring, " "))
	data.Add("state", state)
	return fmt.Sprintf("%v/oauth/authorize?%v", api_base, data.Encode())
}


// Queries a users profile using a user access token.
func (trm *trustmaster) Profile(usertoken *AccessToken) (*Profile, error) {
	if !usertoken.user {
		return nil, errors.New("user access token required")
	}
	if usertoken.Expired() {
		if err := trm.RefreshToken(usertoken); err != nil {
			return nil, err
		}
	}
	c := http.Client{}
	url := fmt.Sprintf("%v/api/v2/me", api_base)
	req, err := http.NewRequest("GET", url, nil)
	if err != nil {
		return nil, err
	}
	req.Header.Add( "Authorization", fmt.Sprintf("Bearer %v", usertoken.Token))
	ret, err := c.Do(req)
	if err != nil {
		return nil, err
	}
	if ret.StatusCode != 200 {
		return nil, errors.New(ret.Status)
	}
	prof := &Profile{}
	rdata, _ := ioutil.ReadAll(ret.Body)
	log.Debug(string(rdata[:]))
	err = json.Unmarshal(rdata, prof)
	if err != nil {
		return nil, err
	}
	return prof, nil
}

// Query trust information about a user (identified by google id)
func (trm *trustmaster) Trust(googleid string, generictoken *AccessToken) (*Trust, error) {
	if !generictoken.generic {
		return nil, errors.New("generic token required")
	}
	if generictoken.Expired() {
		if err := trm.RefreshToken(generictoken); err != nil {
			return nil, err
		}
	}
	c := http.Client{}
	url := fmt.Sprintf("%v/api/v2/user/%v/trust", api_base, googleid)
	log.Debug(url)
	req, err := http.NewRequest("GET", url, nil)
	if err != nil {
		return nil, err
	}
	req.Header.Add( "Authorization", fmt.Sprintf("Bearer %v", generictoken.Token))
	ret, err := c.Do(req)
	if err != nil {
		return nil, err
	}
	if ret.StatusCode != 200 {
		return nil, errors.New(ret.Status)
	}
	trust := &Trust{}
	rdata, _ := ioutil.ReadAll(ret.Body)

	log.Debug(string(rdata[:]))
	err = json.Unmarshal(rdata, trust)
	if err != nil {
		return nil, err
	}
	return trust, nil
}

// Retrieve public key used for access_token verification
func (trm *trustmaster) SigningKey() (*SigningKey, error) {
	c := http.Client{}
	url := fmt.Sprintf("%v/api/meta/keys", api_base)
	req, err := http.NewRequest("GET", url, nil)
	if err != nil {
		return nil, err
	}
	ret, err := c.Do(req)
	if err != nil {
		return nil, err
	}
	if ret.StatusCode != 200 {
		return nil, errors.New(ret.Status)
	}
	key := &SigningKey{}
	rdata, _ := ioutil.ReadAll(ret.Body)
	log.Debug(string(rdata[:]))
	err = json.Unmarshal(rdata, key)
	if err != nil {
		return nil, err
	}
	return key, nil
}